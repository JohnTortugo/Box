% Exemplo de relatório técnico do IC
% Criado por P.J.de Rezende antes do Alvorecer da História.
% Modificado em 97-06-15 e 01-02-26 por J.Stolfi.
% Last edited on 2003-06-07 21:12:18 by stolfi

% modificado em 1o. de outubro de 2008
\documentclass[11pt,twoside]{article}
\usepackage{techrep-ic}

%%% SE USAR INGLÊS, TROQUE AS ATIVAÇÕES DOS DOIS COMANDOS A SEGUIR:
\usepackage[brazil]{babel}
%% \usepackage[english]{babel}

%%% SE USAR CODIFICAÇÃO LATIN1, TROQUE AS ATIVAÇÕES DOS DOIS COMANDOS A
%%% SEGUIR:
%% \usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}
\usepackage[dvips]{graphicx}

\usepackage{multirow}
\usepackage{amsmath}

\bibliographystyle{abbrv}

\begin{document}

%%% PÁGINA DE CAPA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Número do relatório
\TRNumber{???}

% DATA DE PUBLICAÇÃO (PARA A CAPA)
%
\TRYear{12}  % Dois dígitos apenas
\TRMonth{09} % Numérico, 01-12

% LISTA DE AUTORES PARA CAPA (sem afiliações).
\TRAuthor{R. Barboza Jr \and D. C. S. Lucas \and A. S. Ferreira}

% TÍTULO PARA A CAPA (use \\ para forçar quebras de linha).
\TRTitle{Box \\An IA-32 Process Emulator}

\TRMakeCover

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% O que segue é apenas uma sugestão - sinta-se à vontade para
% usar seu formato predileto, desde que as margens tenham pelo
% menos 25mm nos quatro lados, e o tamanho do fonte seja pelo menos
% 11pt. Certifique-se também de que o título e lista de autores
% estão reproduzidos na íntegra na página 1, a primeira depois da
% página de capa.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Nomes de autores ABREVIADOS e titulo ABREVIADO,
% para cabeçalhos em cada página.
%
\markboth{Barboza, Lucas e Ferreira}{Box}
\pagestyle{myheadings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TÍTULO e NOMES DOS AUTORES, completos, para a página 1.
% Use "\\" para quebrar linhas, "\and" para separar autores.
%
\title{Box: An IA-32 Process Emulator}

\author{
 Roberto Barboza Jr
   \thanks{RA: 035712, rbarboza@gmail.com} \and
 Divino C. S. Lucas
   \thanks{RA: 115121, divcesar@gmail.com} \and
 Anderson Soares Ferreira
   \thanks{RA: 974530, asferreira.ferreira@gmail.com}
}

\date{}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract} 
 As máquinas virtuais são ferramentas amplamente utilizadas para resuloção de diversas problemas computacionais e podem ser classificadas de diversas formas, de acordo com sua implementação.
 Como forma de ampliar a compreensão das implicações resultantes das diferentes características de implementação dos diversos tipos de máquinas virtuais, este trabalho apresenta uma comparação de desempenho entre máquinas virtuais interpretadas de sistema e de processo.
 Para tanto, o presente estudo faz a comparação das ferramentas \emph{Bochs}, um gerenciador de máquinas virtuais de sistema, e um gerenciador para máquinas virtuais de processo chamodo \emph{Box}, desenvolvido a partir da ferramenta anterior especificamente para esse estudo.
\end{abstract}

\section{Introdução}
Uma Máquina Virtual (MV) é uma plataforma versátil que pode ser empregada para resolver diversos problemas na área de computação. 
Uma MV pode ser vista como uma camada de software utilizada para prover a integração entre duas interfaces distintas.
As interfaces descritas podem ser tanto \emph{Application Binary Interface} (ABI) em máquinas virtuais de processo, quanto \emph{Instruction Set Architecture} (ISA) em MV de sistema.
Nesse sentido, tais tecnologias ocupam uma posição estratégica que pode ser explorada de diversas formas:
Na emulação de arquiteturas diferentes, permitindo que aplicações escritas para um plataforma específica possa ser executada em outra; para simulação e instrumentação de sistemas ou aplicações; ou otimização dinâmica de binários.

Duas abordagens são frequentemente empregadas para implementar a emulação em uma máquina virtual: interpretação e tradução.
Uma MV que emprega interpretação utiliza funções para simular o comportamento de cada instrução da aplicação sendo emulada. 
O processo de tradução porém, emprega técnicas da área de compiladores para produzir um código binário nativo (possívelmente otimizado) equivalente aquele da aplicação sendo emulada.
É comum encontrarmos MV que, visando maximizar o desempenho, empregam estas abordagens em conjunto.

Nesse texto descrevemos uma proposta de implementação de uma máquina virtual de processo que emprega interpretação como forma de emulação. 
O objetivo desta MA não é otimizar a execução da aplicação sendo emulada mas sim, criar uma infraestrutura que permita a realização de experimentos voltados para a área de máquinas virtuais.
   
\section{Objetivos} \label{sec:objetivos}
As diferentes implementações de MV apresentam características que determinam seu desempenho e aplicabilidade.
Por exemplo, implementações interpretadas tem como principal característica a portabilidade de código, permitindo que sejam utilizadas em diferentes plataformas. 
Em contrapartidada, apresentam desempenho inferior à implementações que utilizam tradução dinâmica de binários.

Neste contexto, são escassos os dados sobre os custos (recursos computacionais e desempenho) para executar uma máquina virtual de sistema e de processos. 
Visto que a primeira apresenta o overhead de emular todos os subsistemas de um computador real e ainda executar um sistema operacional completo, enquanto que na máquina virtual de processos apenas emula o sistema operacional.
Desta forma, o objetivo geral deste trabalhor é apresentar uma comparação sobre o desempenho destes dois tipos de máquinas virtuais.
Como forma de atingir o objetivo descrito, os seguintes objetivos específicos serão desenvolvidos:

\begin{itemize}
 \item Implementação de uma máquina virtual interpretada de processos a partir do emulador de sistemas Bochs;
 \item Implementação de mecanismos de otimização da execução como forma de melhorar o desempenho do ambiente virtualizado.
 \item Aplicação sistemáticas de teste e medição e análise de desempenho do ambiente virtualizado de sistema (\emph{Bochs}) e no ambiente proposto (\emph{Box});
\end{itemize} 

Na próxima seção apresentamos os trabalhos relacionados a este projeto.

\section{Fundamentação Teórica}

\subsection{Máquinas Virtuais}

Uma máquina virtual tem como finalidade, implementar as interfaces de um sistema a partir de outro sistema com características diferentes.
De modo geral, existem dois tipos de interfaces que são implementadas por máquinas virtuais:

\begin{itemize}
 \item \emph{Instruction Set Architecture} (ISA) é a interface que torna visível os recursos do processador como unidades funcionais, registradores e as operações que manipulam esses recursos.    
Um ISA é composto por duas partes: as instruções de computação geral (user-ISA), utilizadas pelas aplicações; e as instruções de controle e gerenciamento de recursos (system-ISA), utilizadas pelo sistema operacional.
Máquinas virtuais que implementam a interface ISA disponibilizam os mesmos recursos existentes em computadores reais, permitindo desta forma a execução de sistemas operacionais completos. 

 \item \emph{Application Binary Interface} (ABI) é a interface que permite que a aplicação tenha acesso a recursos de hardware e serviços disponíveis no sistema\cite{Smith2005a}. 
Ainda segundo os autores, a ABI possui dois componentes básicos: as instruções pertencentes ao user-ISA, ou seja, instruções não privilegiadas; e uma interface para comunicação com o sistema operacional, a qual garante acesso aos recursos do sistema.
Em sistemas operacionais Unix-like, esta interface é chamadas de \emph{system calls} (syscalls). 
Máquinas virtuais que implementam a interface ABI são chamadas de MV de processo, e disponibilizam os mesmos recursos fornecidos pelo sistema operacional, permitindo assim a execução de aplicações.
\end{itemize}

\subsection{Técnicas de Emulação}
Segundo \cite{Smith2005}, a emulação é um processo de implementação das funcionalidades e interfaces de um sistema em outro sistema com características diferentes. 
Como exemplo, podemos citar a execução de máquinas virtuais que permitem a execução de código PowerPC em um arquitetura x86. 
Para isso, faz-se necessária a implementação de interfaces que permitam a emulação do ISA PowerPC, utilizando instruções x86.
A emulação de instruções, como a do exemplo citado anteriormente, é um dos pontos chave para a construção de máquinas virtuais e pode ser classificada de duas formas, de acordo com a sua forma de implementação:

\begin{itemize}
 \item \textbf{Interpretação} Processo no qual cada instrução do programa original (\emph{guest}) está associado a uma rotina que executa a função equivalente a da operação original na plataforma destino (\emph{host}).
A interpretação envolve a recuperação da instrução original (\emph{fetch}), sua decodificação (\emph{decode}) e finalmente a execução da operação equivalente.
 \item \textbf{Tradução de binários} Neste processo um código nativo na arquitetura destino é gerado dinâmicamente a partir do código original da aplicação e tem como função reproduzir o comportamento do código da aplicação original\cite{Sites1993}. 
\end{itemize}

As implicações do uso de interpretação ou tradução influênciam diretamente o desempenho e a aplicabilidade da máquina virtual.
Em sistemas interpretados, o desempenho é relativamente baixo, uma vez que cada instrução é interpretada individualmente, e na maior parte das vezes, repetidamente.
Apesar disso, tais sistemas são extremamente portáveis o que permite sua execução em diversas plataformas, com poucos, ou até mesmo sem nenhuma alteração em seu código original.
Nos sistemas de traduções de binários, existe um custo (\emph{overhead}) inicial elevado, visto que o código original precisa ser traduzido antes de sua execução, porém, uma vez traduzido, o codigo resultante é executado nativamente, o que garante melhor desempenho.

\subsection{Técnicas de Otimização para Interpretação}

\subsection{Application Binary Interface}


\section{Levantamento Bibliográfico}
% Aqui devemos comentar sobre os trabalhos relacionados ao nosso
% podemos comentar sobre o Bochs, o PIN e o HDTrans por exemplo.
% comentar no que nosso sistema é diferente do deles.

%\subsection{Máquinas Virtuais}
O Bochs \cite{Lawton1996} é uma máquina virtual de sistema com suporte a emulação de diversos processadores da família x86 32 e 64 bits. 
Ele preza por portabilidade, e nesse sentido utiliza interpretação como técnica de emulação. Para reduzir o overhead de interpretação, o Bochs utiliza as técnicas como \emph{pre-decoding}\cite{Magnusson1994}, \emph{threaded-interpretation}\cite{Klint1981}, e \emph{lazy evaluation}\cite{Hookway1997}.
O sistema que estamos propondo se diferencia do Bochs por ser voltado à emulação de processos e não de sistemas.

O Pin \cite{Luk2005} é uma máquina virtual de processo que emula os ISAs IA-32 e x86-64. 
Ele é uma ferramenta de código fechado e possui versões tanto para Windows como para Linux, sendo reconhecido por prover uma rica API para criação de ferramentas (Pintools) para análise do comportamento dinâmico de aplicações. 
O Box diferencia-se do PIN por ser uma máquina virtual de código aberto e utilizar interpretação como técnica de emulação.
Em contrapartida, os sistemas se assemelham no aspecto de proverem uma interface para instrumentação de binários e serem emuladores \emph{same-ISA}~\footnote{As duas interfaces da máquina virtual são iguais.}.

O HDTrans \cite{Sridhar2006} é uma máquina virtual de processo para a arquitetura IA-32.
O HDTrans difere do Bochs e do PIN por empregar tradução de binários como técnica de emulação.
No entanto, o HDTrans abre mão de empregar otimizações no código traduzido (o que geralmente é feito para amortizar o overhead de tradução) em favor da implementação de uma tradução simples e rápida.
O Box diferencia-se do HDTrans por empregar interpretação de binários.

O Dynamo \cite{Bala2000} é uma máquina virtual de processo para a arquitetura do HP PA-800. 
Diferentemente do PIN, Bochs e HDTrans, o Dynamo é uma máquina virtual cujo objetivo é otimizar a execução do programa sendo emulado.
Para tanto o Dynamo emprega uma combinação das técnicas de interpretação e emulação. 
O sistema inicialmente interpreta o código da aplicação sendo emulada. 
Uma vez que uma região é declarada como quente, o Dynamo aplica otimizações nesta região e salva o código otimizado em uma cache de traduções. 
Subsequentes invocações do trecho de código original serão emuladas utilizando o código traduzido. 
O Box diferencia-se do Dynamo por não ter o foco na otimização de binários mas sim em ser um sistema que prove uma interface simples para 
instrumentação de binários.

O IA-32 EL \cite{Baraz2003} é uma máquina virtual de processos com o objetivo de suportar a execução de aplicações IA-32 em processadores da família IA-64.
De forma similar ao Dynamo, o IA-32 EL emprega uma abordagem de emulação em duas etapas, porém as duas etapas realizam tradução de código. 
Inicialmente o IA-32 EL efetua a tradução de código em uma granularidade de bloco básico.
Durante essa tradução, código de instrumentação é inserido para detectar blocos básicos que são frequentemente executados. 
Quando um número mínimo de blocos básicos é identificado, o sistema forma uma região de código envolvendo esses blocos básicos, os otimiza e posteriormente salva em uma cache de traduções. 
Execuções subsequentes desses blocos básicos usam a tradução otimizada. 
O Box diferencia-se do IA-32 EL por não fazer tradução de binários.

StarDBT \cite{Wang2007} é uma máquina virtual de pesquisa capaz de fazer traduções de aplicações compiladas para x86 32/64 bits para execução em hardware x86 32 bits.
De forma similar ao IA-32 EL, o StarDBT é um tradutor em duas fases. 
Regiões de código que são infrequentemente executadas são traduzidas utilizando um tradutor simples e rápido, enquanto regiões de código que são frequentemente executadas são traduzidas empregando otimizações de código e posteriormente persistidas em uma cache de traduções. 
O Box diferencia-se do StarDBT por ser capaz de traduzir apenas binários de 32 bits, compilados para Linux e não empregar tradução de binários.



\section{Infraestrutura de Pesquisa}

Como citado na Seção~\ref{sec:objetivos}, o projeto proposto utilizará como
ponto de partida para o desenvolvimento, o emulador de sistema Bochs. Portanto 
a infraestrutura inicial em termos de código fonte será a já presente no Bochs. 
O código fonte do Bochs é escrito em linguagem C++ e disponibilizado para download
no Sourceforge \cite{bochs_site}. Para iniciar o desenvolvimento do Box, criaremos
um ``branch'' do código fonte do Bochs no sistema de versionamento distribuído
GitHub \cite{github}, isto permitirá que os membros do projeto desenvolvam o sistema
de forma colaborativa.

Nenhum hardware, software ou material de consulta além daqueles já adquiridos 
pelos membros do projeto será necessário para o desenvolvimento do projeto.




\section{Metodologia}

Como forma de atingir o objetivo proposto, o trabalho adotará uma abordagem dividida em três etapas logicamente divididas em passos que serão descritos em detalhes a seguir.

\subsection{Implementação da máquina virtual de processos}

Nesta etapa será implementada a versão básica da máquina virtual.
O interpretador proposto utilizará a infraestrutura da interpretador Bochs como ponto de partida para desenvolvimento. 
Por ser uma máquina virtual de sistema, o Bochs implementa mecanismos de emulação para diversos subsistemas de hardware, como cache de instruções, barramentos, discos, placas de vídeo e de rede, etc.
Tais subsistemas são desnecessários em uma máquina virtual de processos, visto que esses dispositivos são gerenciados pelo sistema operacional, e por esse motivo serão removidos do projeto.

\begin{figure}[h]
 \centering
 \includegraphics[width=0.5\columnwidth]{./figures/box-architecture.eps}
 \caption{Arquitetura do interpretador Box}
 \label{fig:box-architecture}
\end{figure}

A Figura \ref{fig:box-architecture} apresenta a arquitetura geral do interpretador, seguido da descrição de seus principais módulos.
Através deste interpretador, será possível carregar e interpretar um executável linux de 32bits com ligação dinâmica.

\begin{itemize}
 \item \textbf{Carregador} Responsável por ler e decodificar o executável principal e suas dependências, montar o espaço de endereçamento onde a interpretação ocorrerá e delegar o controle à CPU.
 \item \textbf{CPU} Módulo responsável por decodificar e interpretar (executar) as instruções x86 32 bits.
% \item \textbf{Decodificador} Neste passo implementaremos as rotinas de decodificação das instruções x86 32 bits.
% \item \textbf{Interpretador} Neste passo implementaremos as rotinas resposáveis por interpretar as instruções do x86 32 bits.
 \item \textbf{Memória} Módulo responsável pelo gerenciamento do espaço de memória reservado para a aplicação e suas dependências.
 \item \textbf{Syscalls} Rotinas que implementam as chamadas ao sistema operacional (\emph{system calls}) da ABI da aplicação sendo emulada (\emph{guest}).
 \item \textbf{Exceções} Módulo de gerenciamento de exceções da CPU (\emph{traps} e \emph{faults}).
\end{itemize}

\subsection{Otimização da máquina virtual}

Nesta etapa serão implementados os passos que adicionarão ao interpretador recursos de instrumentação e otimização de desempenho da interpretação.

\begin{itemize}
 \item \textbf{Otimização} Neste passo implementaremos uma das seguintes técnicas: DICache\cite{Chen2012} ou Threaded-Interpretation\cite{Klint1981}.
 \item \textbf{Instrumentação} Neste passo implementaremos suporte para instrumentação dinâmica das aplicações emuladas.
\end{itemize}
 
\subsection{Análise de desempenho}

Nesta etapa serão conduzidas medições e análises de desempenho do sistema em relação ao emulador \emph{Bochs} e será qunatificado o impacto das técnicas implementadas na etapa 2 no sistema.

\begin{itemize}
 \item \textbf{Desempenho 1} Neste passo avaliaremos o desempenho do sistema em relação ao emulador de sistema Bochs.
 \item \textbf{Desempenho 2} Neste passo iremos avaliar o efeito das técnicas implementadas na etapa 2 no desempenho do sistema.
\end{itemize}

% A descrição da ferramenta de benchmark utilizada não deveria estar na infraestrutura de pesquisa?
Como ferramenta de apoio ao processo de análise será utilizado o MiBench\cite{Guthaus2001}, um pacote de benchmark de código aberto que apresenta um amplo conjunto de testes voltados a avaliação de desempenho de operações se salto (\emph{branchs}) condicionais e não condicionais, ponto flutuante, armazenamento (load/store), entre outros.
 
\subsection{Cronograma}

A Tabela~\ref{tab:cronograma} apresenta o cronograma previsto para o desenvolvimento do Box.
Cada linha representa uma atividades descritas nas subseções anteriores. Cada coluna representa
uma semana durante o desenvolvimento, a primeira semana inicia-se no dia 25 de setembro e a
última semana encerra no dia 21 de novembro, totalizando 8 semanas.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|c|c|c|c|} \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{Atividade}}} & \multicolumn{8}{c|}{\textbf{Semana}} \\ \cline{2-9}
\multicolumn{1}{|c|}{} & 1\textsuperscript{a} & 2\textsuperscript{a} & 3\textsuperscript{a} & 4\textsuperscript{a} & 5\textsuperscript{a} & 6\textsuperscript{a} & 7\textsuperscript{a} & 8\textsuperscript{a} \\ \hline
Carregador  	& $\bullet$ & $\bullet$ & $\bullet$ &  &  &  &  &  \\ \hline
Memória     	& $\bullet$ & $\bullet$ & &  &  &  &  &  \\ \hline
Syscalls    	&  & $\bullet$ & $\bullet$ &  &  &  &  &  \\ \hline
Exceções    	&  & $\bullet$ & $\bullet$ &  &  &  &  &  \\ \hline
Otimizações 	&  &  &  & $\bullet$ & $\bullet$ & $\bullet$ &  &  \\ \hline
Analizes    	&  &  &  &  & $\bullet$ & $\bullet$ & $\bullet$ &  \\ \hline
Relatório Final	&  &  &  &  &  &  & $\bullet$ & $\bullet$ \\ \hline
\end{tabular}
\caption{Cronograma de desenvolvimento do Box}
\label{tab:cronograma}
\end{table}




\section{Conclusão}

Este trabalho apresentou uma proposta de análise de desempenho entre máquinas virtuais interpretadas de sistema e de processo.

Além dos dados provenientes desta análise, o trabalho também apresenta como contribuições o desenvolvimento de emulador interpretado de processos para aplicações Linux de 32bits.
Embora o desenvolvimento desta ferramenta esteja voltado para a produção de dados para a análise de desempenho, tal ferramenta pode ser utilizada em situações como: instrumentação e simulação de aplicações; e como 
módulo de compatibilidade para execução de aplicações Unix-like x86 32bits em diferentes sistemas operacionais ou arquiteturas.

A implementação e análise de técnicas de otimização de desempenho para interpretadores, fornecerá recursos que poderão ser aplicados em outros interpretadores para melhora do seu desempenho. 

\bibliography{box}

\end{document}
