% Exemplo de relatório técnico do IC
% Criado por P.J.de Rezende antes do Alvorecer da História.
% Modificado em 97-06-15 e 01-02-26 por J.Stolfi.
% Last edited on 2003-06-07 21:12:18 by stolfi

% modificado em 1o. de outubro de 2008
\documentclass[11pt,twoside]{article}
\usepackage{techrep-ic}

%%% SE USAR INGLÊS, TROQUE AS ATIVAÇÕES DOS DOIS COMANDOS A SEGUIR:
\usepackage[brazil]{babel}
%% \usepackage[english]{babel}

%%% SE USAR CODIFICAÇÃO LATIN1, TROQUE AS ATIVAÇÕES DOS DOIS COMANDOS A
%%% SEGUIR:
%% \usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}
\usepackage[dvips]{graphicx}
\usepackage{url}
\usepackage{multirow}
\usepackage{amsmath}

\bibliographystyle{abbrv}

\begin{document}

%%% PÁGINA DE CAPA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Número do relatório
\TRNumber{???}

% DATA DE PUBLICAÇÃO (PARA A CAPA)
%
\TRYear{12}  % Dois dígitos apenas
\TRMonth{09} % Numérico, 01-12

% LISTA DE AUTORES PARA CAPA (sem afiliações).
\TRAuthor{R. Barboza Jr \and D. C. S. Lucas \and A. S. Ferreira}

% TÍTULO PARA A CAPA (use \\ para forçar quebras de linha).
\TRTitle{Box \\An IA-32 Process Emulator}

\TRMakeCover

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% O que segue é apenas uma sugestão - sinta-se à vontade para
% usar seu formato predileto, desde que as margens tenham pelo
% menos 25mm nos quatro lados, e o tamanho do fonte seja pelo menos
% 11pt. Certifique-se também de que o título e lista de autores
% estão reproduzidos na íntegra na página 1, a primeira depois da
% página de capa.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Nomes de autores ABREVIADOS e titulo ABREVIADO,
% para cabeçalhos em cada página.
%
\markboth{Barboza, Lucas e Ferreira}{Box}
\pagestyle{myheadings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TÍTULO e NOMES DOS AUTORES, completos, para a página 1.
% Use "\\" para quebrar linhas, "\and" para separar autores.
%
\title{Box: An IA-32 Process Emulator}

\author{
 Roberto Barboza Jr
   \thanks{RA: 035712, rbarboza@gmail.com} \and
 Divino C. S. Lucas
   \thanks{RA: 115121, divcesar@gmail.com} \and
 Anderson Soares Ferreira
   \thanks{RA: 974530, asferreira.ferreira@gmail.com}
}

\date{}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract} 
Máquinas Virtuais são ferramentas amplamente utilizadas para resolução de 
diversos problemas computacionais e podem ser categorizadas por diversos atributos, 
entre eles escopo de emulação (sistema ou processo) e técnica de emulação 
(interpretação ou tradução). Como forma de ampliar a compreensão do \emph{overhead} 
decorrente da emulação do sistema operacional e dispositivos de \emph{hardwar}e em uma
máquina virtual de sistema, este trabalho apresenta uma comparação de 
desempenho entre máquinas virtuais interpretadas de sistema e de processo.
Para tanto, conduzimos uma investigação utilizando duas máquinas virtuais distintas. 
A primeira delas, chamada \emph{Bochs}, é uma máquina virtual de sistema que 
emprega interpretação como técnica de emulação, a segunda é uma máquina virtual 
de processo chamada \emph{Box}, desenvolvido a partir da ferramenta anterior 
especificamente para esse estudo.
\end{abstract}

\section{Introdução}
Uma Máquina Virtual (MV) é uma plataforma versátil que pode ser empregada para resolver diversos problemas na área de computação. 
Uma MV pode ser visualizada como uma camada utilizada para prover a integração entre duas interfaces (possívelmente distintas). Esta camada pode ser implementada com emulação em software, virtualização em hardware ou uma composição das duas abordagens.
As interfaces podem ser tanto a \emph{Application Binary Interface} (ABI) em MV de processo, quanto a \emph{Instruction Set Architecture} (ISA) em MVs de sistema.
Dessa forma, tais ferramentas ocupam uma posição estratégica que pode ser explorada de diversas formas:
\textit{cross-platform emulation} - permitindo que aplicações escritas para uma plataforma sejam executadas em outra; 
\textit{simulação} - simulação do comportamento do hardware durante a execução do programa; \textit{análise} - análise do
perfil de execução das aplicações; \textit{otimização} - aplicar otimizações no código da aplicação utilizando informações
obtidas durante a execução do código.  

Duas abordagens são frequentemente empregadas para implementar a emulação de código em uma máquina virtual: interpretação e tradução.
Uma MV que emprega interpretação utiliza funções para simular o comportamento de cada instrução da aplicação sendo emulada. 
O processo de tradução porém, emprega técnicas da área de compiladores para produzir um código binário nativo (possívelmente otimizado) equivalente àquele da aplicação sendo emulada.
É comum encontrarmos MVs que, visando maximizar o desempenho, empregam estas abordagens em conjunto.

Note que, uma MV de sistema não emula apenas as instruções da arquitetura alvo, mas toda uma infraestrutura de hardware
necessária para executar um sistema operacional, nisto são está incluso dispositivos como placa de rede, hierarquia de memória,
placa gráfica e etc. Para tarefas como \textit{cross-platform emulation} e perfilamento da execução do código de uma aplicação
em específico o uso de uma MV de sistema agrega ao overhead de emulação da aplicação também o overhead de emulação destes 
dispositivos e do sistema operacional. Portanto frequentemente, nestes cenários, uma máquina virtual de processo é preferível
em relação a uma MV de sistema.

Nesse texto apresentamos uma proposta de avaliação do overhead de emulação do sistema operacional e dispositivos de hardware
em uma máquina virtual de sistema interpretada em relação a uma máquina virtual interpretada de processo. Para tanto, propomos
a transformação de uma máquina virtual de sistema em uma máquina virtual de processo. Além de uma melhor compreensão do overhead
de emulação em uma máquina virtual de sistema este trabalho tem como resultado uma infraestrutura para a realização de experimentos
voltados para a área de máquinas virtuais. 

Este texto está organizado da seguinte forma. Na Seção~\ref{sec:objetivos} apresentamos com certo nível de detalhamento nossos objetivos. 
Na Seção~\ref{sec:fundamentacao} apresentamos a fundamentação teórica para a realização do projeto. Na Seção~\ref{sec:bibliografia} apresentamos
um levantamento bibliográfico da área de máquinas virtuais a nível de binários. A Seção~\ref{sec:infraestrutura} e Seção~\ref{sec:metodologia}
descrevem a infraestrutura e a metodologia proposta para a realização do projeto. Por fim a Seção~\ref{sec:conclusao} apresenta a conclusão do trabalho. 
  
  
  
  
\section{Objetivos} \label{sec:objetivos}
As diferentes implementações de MVs apresentam características que determinam seu desempenho e aplicabilidade.
Por exemplo, implementações interpretadas tem como principal característica a portabilidade de código, permitindo que sejam utilizadas em diferentes plataformas. 
Em contrapartida, apresentam desempenho inferior a implementações que utilizam tradução dinâmica de binários.

Neste contexto, são escassos os dados sobre os custos (recursos computacionais e desempenho) para executar uma máquina virtual de sistema e de processos. 
Visto que a primeira apresenta o overhead de emular todos os subsistemas de um computador real e ainda executar um sistema operacional completo, enquanto que a máquina virtual de processos apenas emula o sistema operacional.
Desta forma, o objetivo geral deste trabalho é apresentar uma comparação sobre o desempenho destes dois tipos de máquinas virtuais.
Como forma de atingir o objetivo descrito, os seguintes objetivos específicos serão desenvolvidos:

\begin{itemize}
 \item Implementação de uma máquina virtual interpretada de processos a partir do emulador de sistemas Bochs;
 \item Implementação de mecanismos de otimização da execução como forma de melhorar o desempenho do ambiente virtualizado.
 \item Aplicação sistemáticas de teste e medição e análise de desempenho do ambiente virtualizado de sistema (\emph{Bochs}) e no ambiente proposto (\emph{Box});
\end{itemize} 

Na próxima seção apresentamos os trabalhos relacionados a este projeto.






\section{Fundamentação Teórica} \label{sec:fundamentacao}

\subsection{Máquinas Virtuais}

Uma máquina virtual tem como finalidade implementar as interfaces de um sistema a partir de outro sistema.
De modo geral, existem dois tipos de interfaces que são implementadas por máquinas virtuais:

\begin{itemize}
 \item \emph{Instruction Set Architecture} (ISA) é a interface que torna visível os recursos do processador como unidades funcionais, registradores e as operações que manipulam esses recursos.    
Um ISA é composto por duas partes: as instruções de computação geral (user-ISA), utilizadas pelas aplicações; e as instruções de controle e gerenciamento de recursos (system-ISA), utilizadas pelo sistema operacional.

Máquinas virtuais que implementam a interface ISA disponibilizam os mesmos recursos existentes em computadores reais, permitindo desta forma a execução de sistemas operacionais completos. 

 \item \emph{Application Binary Interface} (ABI) é a interface que permite que a aplicação tenha acesso a recursos de hardware e serviços disponíveis no sistema\cite{Smith2005a}. 
Ainda segundo os autores, a ABI possui dois componentes básicos: as instruções pertencentes ao user-ISA; e uma interface para comunicação com o sistema operacional, a qual garante acesso aos recursos do sistema. Em sistemas operacionais Unix-like, esta interface é chamadas de \emph{system calls} (syscalls). 

A ABI também define convenções para tipos de dados, endianness, alinhamento, chamadas de funções (como devem ser passados os argumentos e o retorno), e o formato utilizado para representar arquivos binários executáveis e bibliotecas dinâmicas.

Máquinas virtuais que implementam a interface ABI são chamadas de MVs de processo, e disponibilizam os mesmos recursos fornecidos pelo sistema operacional, permitindo assim a execução de aplicações.
\end{itemize}

\subsection{Técnicas de Emulação}
\label{emulacao}
Segundo \cite{Smith2005}, a emulação é um processo de implementação das funcionalidades e interfaces de um sistema em outro sistema com características diferentes. 
Como exemplo, podemos citar a execução de máquinas virtuais que permitem a execução de código PowerPC em um arquitetura x86. 
Para isso, faz-se necessária a implementação de interfaces que permitam a emulação do ISA PowerPC, utilizando instruções x86.
A emulação de instruções, como a do exemplo citado anteriormente, é um dos pontos chave para a construção de máquinas virtuais e pode ser classificada de duas formas, de acordo com a sua forma de implementação:

\begin{itemize}
 \item \textbf{Interpretação} Processo no qual cada instrução do programa original (\emph{guest}) está associado a uma rotina que executa a função equivalente a da operação original na plataforma destino (\emph{host}).
A interpretação envolve a recuperação da instrução original (\emph{fetch}), sua decodificação (\emph{decode}) e finalmente a execução da operação equivalente.
 \item \textbf{Tradução de binários} Neste processo um código nativo na arquitetura destino é gerado dinâmicamente a partir do código original da aplicação e tem como função reproduzir o comportamento do código da aplicação original\cite{Sites1993}. 
\end{itemize}

As implicações do uso de interpretação ou tradução influênciam diretamente o desempenho e a aplicabilidade da máquina virtual.
Em sistemas interpretados, o desempenho é relativamente baixo, uma vez que cada instrução é emulada individualmente e, na maior parte das vezes, repetidamente.
Apesar disso, tais sistemas são extremamente portáveis, o que permite sua execução em diversas plataformas com poucas ou até mesmo nenhuma alteração em seu código original.
Nos sistemas de traduções de binários, existe um custo (\emph{overhead}) inicial elevado, visto que o código original precisa ser traduzido antes de sua execução, porém, uma vez traduzido, o codigo resultante é executado nativamente, o que garante melhor desempenho.

\subsection{Técnicas de Otimização para Interpretação}

A forma mais básica de interpretação foi descrita na seção \ref{emulacao}: há um loop principal que busca a instrução original, decodifica-a e chama a função responsável pela execução da instrução, retornando ao loop principal logo em seguida. No entanto, existem diversas técnicas que tornam a interpretação um processo mais eficiente. Algumas delas estão listadas a seguir:

\begin{itemize}

 \item \textbf{Threaded Interpretation} São adicionadas ao final das funções que emulam cada uma das intruções a busca pela próxima instrução, sua decodificação e a chamada para a função responsável pela execução da instrução. Note que não existe mais um loop principal no interpretador.

 \item \textbf{Pre Decoding} O código original é pré decodificado em estruturas mais simples de serem decodificadas, de forma simplificar este passo da interpretação.

 \item \textbf{Direct Threaded Interpretation} Utilizado em conjunto ao \textbf{Pre Decoding}, coloca-se diretamente os endereços das rotinas que emulam a instrução original, de forma que ao se ler a instrução pré-decodificada o interpretador faz um salto indireto diretamente a rotina.

\end{itemize}

\subsection{Executable and Linking Format}

%A \emph{Application Binary Interface} (ABI) é a interface entre um binário e outros binários e %entre um binário e o sistema operacional. 
%Ela define convenções para tipos de dados, endianness, alinhamento, chamadas de funções (como %devem ser passados os argumentos e o retorno) e syscalls, e, mais especificamente, o formato que %os arquivos binários devem ter.

\emph{Executable and Linking Format} (ELF)\cite{SCO1997} é o formato binário flexível e extensível, utilizado atualmente em diversos sistemas Unix-like.
Os principais tipos de arquivos representados pelo formato ELF são:

\begin{itemize}
 \item \textbf{Relocatable File} representa um arquivo objeto que contém dados e código que serão linkados a outro binário para criar um executável ou objeto compartilhado.
 \item \textbf{Executable File} contém um programa que pode ser executado.
 \item \textbf{Shared Object} representa um biblioteca dinâmica que contém código e dados que podem ser linkados a outro objeto compartilhado, criando um terceiro objeto compartilhado, ou pode ser combinado a um executável pelo linker dinâmico e outros objetos compartilhados para a criação de uma imagem de processo.
\end{itemize}

A organização de um arquivo ELF é composta por um cabeçalho principal (\emph{ELF Header}), seguido por cabeçalhos de seção, descrevendo seções de informações (instruções, dados, símbolos) utilizados na linkagem, ou cabeçalhos de programa, que contém os segmentos da aplicação e as informações necessárias para a criação do processo executável. 





\section{Levantamento Bibliográfico}  \label{sec:bibliografia}
% Aqui devemos comentar sobre os trabalhos relacionados ao nosso
% podemos comentar sobre o Bochs, o PIN e o HDTrans por exemplo.
% comentar no que nosso sistema é diferente do deles.

%\subsection{Máquinas Virtuais}
O Bochs \cite{Lawton1996} é uma máquina virtual de sistema com suporte a emulação de diversos processadores da família x86 32 e 64 bits. 
Ele preza por portabilidade, e nesse sentido utiliza interpretação como técnica de emulação. Para reduzir o overhead de interpretação, o Bochs utiliza técnicas como \emph{pre-decoding}\cite{Magnusson1994}, \emph{threaded-interpretation}\cite{Klint1981}, e \emph{lazy evaluation}\cite{Hookway1997}.
O sistema que estamos propondo se diferencia do Bochs por ser voltado à emulação de processos e não de sistemas.

O Pin \cite{Luk2005} é uma máquina virtual de processo que emula os ISAs IA-32 e x86-64. 
Ele é uma ferramenta de código fechado e possui versões tanto para Windows como para Linux, sendo reconhecido por prover uma rica API para criação de ferramentas (Pintools) para análise do comportamento dinâmico de aplicações. 
O Box diferencia-se do PIN por ser uma máquina virtual de código aberto e utilizar interpretação como técnica de emulação.
Em contrapartida, os sistemas se assemelham no aspecto de proverem uma interface para instrumentação de binários e serem emuladores \emph{same-ISA}~\footnote{As duas interfaces da máquina virtual são iguais.}.

O HDTrans \cite{Sridhar2006} é uma máquina virtual de processo para a arquitetura IA-32.
O HDTrans difere-se do Bochs e do PIN por empregar tradução de binários como técnica de emulação.
No entanto, o HDTrans abre mão de empregar otimizações no código traduzido (o que geralmente é feito para amortizar o overhead de tradução) em favor da implementação de uma tradução simples e rápida.
O Box diferencia-se do HDTrans por empregar interpretação de binários.

O Dynamo \cite{Bala2000} é uma máquina virtual de processo para a arquitetura do HP PA-800. 
Diferentemente do PIN, Bochs e HDTrans, o Dynamo é uma máquina virtual cujo objetivo é otimizar a execução do programa sendo emulado.
Para tanto o Dynamo emprega uma combinação das técnicas de interpretação e emulação. 
O sistema inicialmente interpreta o código da aplicação sendo emulada. 
Uma vez que uma região é declarada como quente, o Dynamo aplica otimizações nesta região e salva o código otimizado em uma cache de traduções. 
Subsequentes invocações do trecho de código original serão emuladas utilizando o código traduzido. 
O Box diferencia-se do Dynamo por não ter o foco na otimização de binários mas sim em ser um sistema que prove uma interface simples para 
instrumentação de binários.

O IA-32 EL \cite{Baraz2003} é uma máquina virtual de processos com o objetivo de suportar a execução de aplicações IA-32 em processadores da família IA-64.
De forma similar ao Dynamo, o IA-32 EL emprega uma abordagem de emulação em duas etapas, porém as duas etapas realizam tradução de código. 
Inicialmente o IA-32 EL efetua a tradução de código em uma granularidade de bloco básico.
Durante essa tradução, código de instrumentação é inserido para detectar blocos básicos que são frequentemente executados. 
Quando um número mínimo de blocos básicos é identificado, o sistema forma uma região de código envolvendo esses blocos básicos, os otimiza e posteriormente salva em uma cache de traduções. 
Execuções subsequentes desses blocos básicos usam a tradução otimizada. 
O Box diferencia-se do IA-32 EL por não fazer tradução de binários.

StarDBT \cite{Wang2007} é uma máquina virtual de pesquisa capaz de fazer traduções de aplicações compiladas para x86 32/64 bits para execução em hardware x86 32 bits.
De forma similar ao IA-32 EL, o StarDBT é um tradutor em duas fases. 
Regiões de código que são infrequentemente executadas são traduzidas utilizando um tradutor simples e rápido, enquanto regiões de código que são frequentemente executadas são traduzidas empregando otimizações de código e posteriormente persistidas em uma cache de traduções. 
O Box diferencia-se do StarDBT por ser capaz de traduzir apenas binários de 32 bits, compilados para Linux e não empregar tradução de binários.





\section{Infraestrutura de Pesquisa} \label{sec:infraestrutura}

Como citado na Seção~\ref{sec:objetivos}, o projeto proposto utilizará como
ponto de partida para o desenvolvimento, o emulador de sistema Bochs. Portanto 
a infraestrutura inicial em termos de código fonte será a já presente no Bochs. 
O código fonte do Bochs é escrito em linguagem C++ e disponibilizado para download
no Sourceforge \cite{bochs_site}. Para iniciar o desenvolvimento do Box, criaremos
um ``branch'' do código fonte do Bochs no sistema de versionamento distribuído
GitHub \cite{github}, isto permitirá que os membros do projeto desenvolvam o sistema
de forma colaborativa.

Nenhum hardware, software ou material de consulta além daqueles já adquiridos 
pelos membros do projeto será necessário para o desenvolvimento do projeto.





\section{Metodologia}  \label{sec:metodologia}

Como forma de atingir o objetivo proposto, o trabalho adotará uma abordagem dividida em três etapas logicamente divididas em passos que serão descritos em detalhes a seguir.

\subsection{Implementação da máquina virtual de processos}

Nesta etapa será implementada a versão básica da máquina virtual.
O interpretador proposto utilizará a infraestrutura da interpretador Bochs como ponto de partida para desenvolvimento. 
Por ser uma máquina virtual de sistema, o Bochs implementa mecanismos de emulação para diversos subsistemas de hardware, como cache de instruções, barramentos, discos, placas de vídeo e de rede, etc.
Tais subsistemas são desnecessários em uma máquina virtual de processos, visto que esses dispositivos são gerenciados pelo sistema operacional, e por esse motivo serão removidos do projeto.

\begin{figure}[h]
 \centering
 \includegraphics[width=0.5\columnwidth]{./figures/box-architecture.eps}
 \caption{Arquitetura do interpretador Box}
 \label{fig:box-architecture}
\end{figure}

A Figura \ref{fig:box-architecture} apresenta a arquitetura geral do interpretador, seguido da descrição de seus principais módulos.
Através deste interpretador, será possível carregar e interpretar um executável linux de 32bits com ligação dinâmica.

\begin{itemize}
 \item \textbf{Carregador} Responsável por ler e decodificar o executável principal e suas dependências, montar o espaço de endereçamento onde a interpretação ocorrerá e delegar o controle à CPU.
 \item \textbf{CPU} Módulo responsável por decodificar e interpretar (executar) as instruções x86 32 bits.
% \item \textbf{Decodificador} Neste passo implementaremos as rotinas de decodificação das instruções x86 32 bits.
% \item \textbf{Interpretador} Neste passo implementaremos as rotinas resposáveis por interpretar as instruções do x86 32 bits.
 \item \textbf{Memória} Módulo responsável pelo gerenciamento do espaço de memória reservado para a aplicação e suas dependências.
 \item \textbf{Syscalls} Rotinas que implementam as chamadas ao sistema operacional (\emph{system calls}) da ABI da aplicação sendo emulada (\emph{guest}).
 \item \textbf{Exceções} Módulo de gerenciamento de exceções da CPU (\emph{traps} e \emph{faults}).
\end{itemize}

\subsection{Otimização da máquina virtual}

Nesta etapa serão implementados os passos que adicionarão ao interpretador recursos de instrumentação e otimização de desempenho da interpretação.

\begin{itemize}
 \item \textbf{Otimização} Neste passo implementaremos uma das seguintes técnicas: DICache\cite{Chen2012} ou Threaded-Interpretation\cite{Klint1981}.
 \item \textbf{Instrumentação} Neste passo implementaremos suporte para instrumentação dinâmica das aplicações emuladas.
\end{itemize}
 
\subsection{Análise de desempenho}

Nesta etapa serão conduzidas medições e análises de desempenho do sistema em relação ao emulador \emph{Bochs} e será qunatificado o impacto das técnicas implementadas na etapa 2 no sistema.

\begin{itemize}
 \item \textbf{Desempenho 1} Neste passo avaliaremos o desempenho do sistema em relação ao emulador de sistema Bochs.
 \item \textbf{Desempenho 2} Neste passo iremos avaliar o efeito das técnicas implementadas na etapa 2 no desempenho do sistema.
\end{itemize}

% A descrição da ferramenta de benchmark utilizada não deveria estar na infraestrutura de pesquisa?
Como ferramenta de apoio ao processo de análise será utilizado o MiBench\cite{Guthaus2001}, um pacote de benchmark de código aberto que apresenta um amplo conjunto de testes voltados a avaliação de desempenho de operações se salto (\emph{branchs}) condicionais e não condicionais, ponto flutuante, armazenamento (load/store), entre outros.
 
\subsection{Cronograma}

A Tabela~\ref{tab:cronograma} apresenta o cronograma previsto para o desenvolvimento do Box.
Cada linha representa uma atividades descritas nas subseções anteriores. Cada coluna representa
uma semana durante o desenvolvimento, a primeira semana inicia-se no dia 25 de setembro e a
última semana encerra no dia 21 de novembro, totalizando 8 semanas.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|c|c|c|c|} \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{Atividade}}} & \multicolumn{8}{c|}{\textbf{Semana}} \\ \cline{2-9}
\multicolumn{1}{|c|}{} & 1\textsuperscript{a} & 2\textsuperscript{a} & 3\textsuperscript{a} & 4\textsuperscript{a} & 5\textsuperscript{a} & 6\textsuperscript{a} & 7\textsuperscript{a} & 8\textsuperscript{a} \\ \hline
Carregador  	& $\bullet$ & $\bullet$ & $\bullet$ &  &  &  &  &  \\ \hline
Memória     	& $\bullet$ & $\bullet$ & &  &  &  &  &  \\ \hline
Syscalls    	&  & $\bullet$ & $\bullet$ &  &  &  &  &  \\ \hline
Exceções    	&  & $\bullet$ & $\bullet$ &  &  &  &  &  \\ \hline
Otimizações 	&  &  &  & $\bullet$ & $\bullet$ & $\bullet$ &  &  \\ \hline
Análises    	&  &  &  &  & $\bullet$ & $\bullet$ & $\bullet$ &  \\ \hline
Relatório Final	&  &  &  &  &  &  & $\bullet$ & $\bullet$ \\ \hline
\end{tabular}
\caption{Cronograma de desenvolvimento do Box}
\label{tab:cronograma}
\end{table}






\section{Conclusão}  \label{sec:conclusao}

Este trabalho apresentou uma proposta de análise de desempenho entre máquinas virtuais interpretadas de sistema e de processo.

Além dos dados provenientes desta análise, o trabalho também apresenta como contribuição o desenvolvimento de emulador interpretado de processos para aplicações Linux de 32bits.
Embora o desenvolvimento desta ferramenta esteja voltado para a produção de dados para a análise de desempenho, tal ferramenta pode ser utilizada em situações como instrumentação e simulação de aplicações e como 
módulo de compatibilidade para execução de aplicações Unix-like x86 32bits em diferentes sistemas operacionais ou arquiteturas.

A implementação e análise de técnicas de otimização de desempenho para interpretadores fornecerá recursos que poderão ser aplicados em outros interpretadores para melhora do seu desempenho. 

\bibliography{box}

\end{document}
